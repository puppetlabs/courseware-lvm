<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
<div id="content">
<h1>The Learning Virtual Machine (VM)</h1>

<p>If you want to learn more about Puppet or are a new user of Puppet or just looking to have fun exploring Puppet, then you've come to the right place. This is our free downloadable Learning VM for you to play around with and explore. The Learning VM is a companion to our Puppet Quests a few sections below, which are a series of tutorials about the Puppet language and using its various tools. Although, please keep in mind that this Learning VM focuses on using Puppet Enterprise at its core, but most of the quests can also apply to Puppet open source.</p>

<h2>Learning Puppet</h2>

<p>So what is Puppet? Great question! Puppet is a versatile tool for managing your servers. You simply describe your machine configurations in an easy-to-read declarative language (such as Ruby), and Puppet will ensure that your systems conform to and stay in that desired state.</p>

<p>Associated with this Learning VM are a series of quest adventures that will teach you about about managing your systems with Puppet. These quests start out very basic to accommodate all users no matter your experience level. Essentially, we provide everyone a level starting point to build from. From there, its up to you how much you want to learn and what exactly you want to learn. We hope that this will be the beginning of an interesting journey towards automating your systems management efforts.</p>

<h2>The Quest Structure</h2>

<p>The individual quest design is very simple in its structure and consists of three parts.</p>

<ol>
<li>An introduction to the quest as it relates to Puppet</li>
<li>A themed storyline of the quest and how Puppet fits in.</li>
<li>Going on your quest adventure! (Applying what your knowledge in the Learning VM!)</li>
</ol>
<p>In the below example quest (you don't need to do anything), in order to understand how Puppet is useful and can be leveraged to simplify configuration management, we will automate a task with Puppet. This is an example quest:</p>

<p><strong><em>Quest</em></strong>: </p>

<blockquote>
<p>Let's assume that you work as an engineer in a web-development firm. You are tasked with configuring Virtual Machines for use by web developers. You are given a list of requirements, such as:  </p>

<ul>
<li>the usernames of the web developers </li>
<li>a list of one of more user groups</li>
<li>a list of files and directories that should be present on the machine<br>
</li>
<li>a list of software packages that should be installed on the machine </li>
<li>a website served by the Apache2 webserver</li>
<li>a database that should be present on the machine</li>
</ul>
</blockquote>

<p>Each of the above steps are tasks within this quest that you will need to complete.</p>

<p>In the above example you <em>could</em> manually configure the Learning VM by completing a list of tasks each time you need a VM. However, I have a feeling you'll soon realize that this manual process boils down to repeating the same set of tasks over and over again. In addition, you're not even using Puppet, so there really is no point for you to continue.</p>

<p>In relation to this example, we will teach you how to use Puppet to <em>describe</em> your requirements to configure the VM appropriately and automate the process of configuring all the other VM's correctly and quickly.</p>

<h3>Ready to start your <a href="docs.puppetlabs.com/learning">Quest #1</a> adventure?</h3>

<h1></h1>

<div class="page-break"></div>

<h3>Resources</h3>

<p>Imagine a system’s configuration as a collection of many independent atomic units - call them “resources.”</p>

<p>These pieces vary in size, complexity, and lifespan. Any of the following (and more) can be modeled as a single resource:</p>

<ul>
<li>A user account</li>
<li>A specific file</li>
<li>A directory of files</li>
<li>A software package</li>
<li>A running service</li>
<li>A scheduled cron job</li>
</ul>
<p>On a given system, you might care about several of each the above types. For example, you may want to ensure that several different users are present on the system. Therefore, it follows that for each type of resource, there are several individual resources, each with a unique <strong>title</strong>.</p>

<p>Also, the various resources may have characteristics that you care to manage - for example, you may want to manage the shell used by users, or their home directories. Each of these details that you care about for the resource is called an <strong>attribute</strong>, and each attribute will have a <strong>value</strong>.</p>

<p>In summary, you can describe resource of various types, and values for the attributes that pertain to the resource. For example, on a certain Unix/Linux machine, you may want to ensure that a user with the username "elmo" is present on the system, with the home directory "/home/elmo" and that his shell is the Bourne Again Shell (bash).</p>

<p>In order to convey your intentions in a manner understandable by Puppet, you use Puppet's Domain-Specific Language (DSL) to describe your requirements. Here is the first example of using Puppet's DSL to describe our user:</p>

<pre><code>    user { 'elmo':
      ensure =&gt; 'present',
      shell  =&gt; '/bin/bash',
      home   =&gt; '/home/elmo',
    }
</code></pre>

<p>The above is an example of a <strong>resource declaration</strong>, since you are describing how you want the resource to be configured. As you noticed, there is always:</p>

<ul>
<li>a <strong>type</strong>, which is "user" in the example above,</li>
<li>a <strong>title</strong>, which is "elmo" here,</li>
<li>and one or more <strong>attributes</strong> with specified <strong>values</strong> - for example, the attribute "shell" has the value '/bin/bash'.</li>
</ul>
<p>Resource declarations such as the above are usually placed in a file with the extension ".pp". A file with the extension .pp, that contains puppet code is called a puppet <strong>manifest</strong>.</p>

<h4>Manifests</h4>

<p>Manifests are files containing code written in Puppet's DSL, with the filename extension ".pp". These describe how you want various resources to be configured for a system.</p>

<h4>Inspecting resources</h4>

<p>Puppet provides you with a tool to inspect resources on your systems.</p>

<p>You are already logged in to the Learning Puppet VM, as user root.</p>

<p>Run the following command:</p>

<pre><code># puppet resource service
service { 'NetworkManager': 
  ensure =&gt; 'stopped',
  enable =&gt; 'false',
}
service { 'acpid':
  ensure =&gt; 'running',
  enable =&gt; 'true', 
}
service { 'anacron':
  ensure =&gt; 'stopped', 
  enable =&gt; 'true',
}
...
... (etc.)
</code></pre>

<p>The <code>puppet resource</code> command lets you inspect resources on your system. In the above example, <code>puppet resource service</code> returns all the resources of type 'service' on the system, in Puppet's DSL! If you pass an additional parameter - the name of a specific resource of the type, the command will return information regarding only that resource. For example, to inspect the <code>anacron</code> service, execute the following command on the VM:</p>

<pre><code>puppet resource service anacron
</code></pre>

<p>You can also inspect a specific resource by providing its title. Run the following command:</p>

<pre><code># puppet resource user root
user { 'root':
  ensure           =&gt; 'present',
  comment          =&gt; 'root',
  gid              =&gt; '0',
  home             =&gt; '/root',
  password         =&gt; '$1$jrm5tnjw$h8JJ9mCZLmJvIxvDLjw1M/',
  password_max_age =&gt; '99999',
  password_min_age =&gt; '0',
  shell            =&gt; '/bin/bash',
  uid              =&gt; '0',
}
</code></pre>

<blockquote>
<p>In the above, what is the <em>type</em> of the resource?<br>
What is the <em>title</em> of the resource?
What is the <em>value</em> of the <em>attribute</em> 'home'?</p>
</blockquote>

<h4>Resource Types</h4>

<p>Puppet has many built-in resource types. Each type can behave a bit differently, and has a different set of attributes available.  </p>

<p>There are several ways to get information about the resource types available for use in Puppet:</p>

<ol>
<li>
<p>The Cheat Sheet  </p>

<p>Not all resource types are equally common or useful, so weʼve made a   printable cheat sheet that explains the eight most useful types.    <a href="http://docs.puppetlabs.com/puppet_core_types_cheatsheet.pdf">Download the core types cheat sheet here</a>.</p>
</li>
<li>
<p>The Type Reference  </p>

<p>The <a href="http://docs.puppetlabs.com/references/latest/type.html">type reference page </a>lists all of Puppetʼs built-in resource types,   in  extreme detail. It can be a bit overwhelming for a new user, but    it  has most of the info youʼll need in a normal day of writing Puppet     code.  </p>
</li>
<li>
<p>Puppet Describe  </p>

<p>The <code>puppet describe</code> subcommand can list information about the     currently installed resource types on a given machine.  </p>

<p><code>puppet describe -l</code> — List all of the resource types available on the    system.  </p>

<p><code>puppet describe -s &lt;TYPE&gt;</code> — Print short information about a type,   without describing every attribute.  </p>

<p><code>puppet describe &lt;TYPE&gt;</code> — Print long information, similar to what    appears in the type reference.</p>
</li>
</ol>
<p>As an aside, in addition to the resource types provided by Puppet by default, you can create and use additional resource types by means of plugins.</p>

<blockquote>
<p>Try the <code>puppet describe</code> command on the Learning Puppet VM, and learn about the 'host' resource type.</p>
</blockquote>

<h5>Manage a user, 'gonzo' using puppet.</h5>

<p>To complete this task:  </p>

<blockquote>
<ol>
<li><p>In the Learning Puppet VM, in your home directory (<code>/root</code>), create a new file named <code>user.pp</code>  </p></li>
<li>
<p>Edit the file <code>user.pp</code> and describe user gonzo using Puppet's DSL.  </p>

<ul>
<li>You may want to refer to the example above that describes user 'elmo'.<br>
</li>
<li>Remember that you can use <code>puppet describe user</code> and <code>puppet resource user</code> for help.<br>
</li>
</ul>
</li>
<li>
<p>Once completed, run the following command:  </p>

<p>puppet apply /root/user.pp</p>
</li>
</ol>
</blockquote>

<p>You will see that puppet does, indeed create a user called gonzo!</p>

<h4>Puppet Apply</h4>

<p>Try the command <code>puppet help apply</code> to learn more about the <code>puppet apply</code> command. We learn that puppet apply is the standalone puppet execution tool. You can use it to apply individual manifests.</p>

<p>This is very handy for learning to write code in Puppet's DSL. However, if you wanted to, you could describe the configuration of an entire system as a list of all the resources you want to manage on the system in a single puppet manifest file. But as you can imagine, that might end up being a <em>really</em> long file! We will see how to make this more of a manageable and coherent process when we learn about Classes in a subsequent lesson.</p>

<h4>Abstracting away complexity</h4>

<p>Although the example we described above manages a user on a Unix/Linux system, other operating systems have users too. The <em>attributes</em> for the users might change, along with the values, depending on the operating system - but fundamentally, regardless of the operating system, we care about managing a <em>type</em> of resource called "user".</p>

<p>Puppet abstracts away the complexity of managing resources of various types, such as the user resource, by leveraging different <strong>providers</strong> to realize the resource on the various operating systems. The implementation of how users are realized on various OS-es might differ - the tools that provide these implementations on various OS-es are the <em>providers</em> for the user resource type.</p>

<p>Puppet has a <em>Resource Abstraction Layer</em> (RAL) that consists of types (high-level models of differnt kinds of resources) and providers (platform-specific implementations for the different types), and Puppet automatically translates your description of how you want the various resources you manage should be configured to the appropriate platform-specific commands required to realize your description.</p>

<h1></h1>

<div class="page-break"></div>

<h2>Classes and Modules</h2>

<p>We have seen how there are <em>resources</em> and how we seek to configure systems by means of specifying the values for the attributes of the resources we want to manage. The task of configuring a machine will involve defining the attributes of several different resources, possibly of different types. Classes provide for a layer of abstraction, wherein you can group together resources.</p>

<p>A <strong>Class</strong> in Puppet is a collection of resources, which, once defined, can be declared as a single unit.  </p>

<h3>Defining Classes</h3>

<p>Let's assume that we need to manage users on a system - this time with some additional requirements.  </p>

<ul>
<li>Users on the system should have their home directories in the directory <code>/mnt/home</code>
</li>
<li>We need to ensure that a group, with the name of <code>staff</code> is present</li>
<li>We also need two users, <code>elmo</code> and <code>gonzo</code>, who are members of the group <code>staff</code>
</li>
<li>elmo's home directory should be <code>/mnt/home/elmo</code>. </li>
</ul>
<p>We can create a definition for a class called users that does all of the above, as follows:</p>

<pre><code>class users {

    user { 'elmo':
      ensure =&gt; present,
      gid    =&gt; 'staff',
      home   =&gt; '/mnt/home/elmo',   
    }

    user { 'gonzo':
      ensure =&gt; present,
      gid    =&gt; 'staff',
      home   =&gt; '/mnt/home/elmo',   
    }

    group { 'staff':
      ensure =&gt; present,
      gid    =&gt; '1001',
    }

    file { '/mnt/home/':
      ensure =&gt; directory,
      mode   =&gt; '0755',
    }

}  
</code></pre>

<p>In the above, we <strong><em>define</em></strong> a class called <code>users</code>, which is a collection of three different resources - a user resource, a group resource, and a file resource. The above description is both elegant, and self-documenting.</p>

<p>Now that we have a class called users, we can include the above class in the configuration of a machine to manage users on the machine.</p>

<h3>Declaring classes</h3>

<p>As we learnt earlier, a class is a collection or group of resources. In the previous section, we saw an example of a class definition. The question that needs answering now, is, how can we use the class definition? How can we tell Puppet to <em>use</em> the defintion as part of configuring a system?</p>

<p>You can direct Puppet to apply a class definition on a system by using the <strong><em>include</em></strong> keyword. By creating a puppet manifest - we already know that Puppet manifests are files with the extension ".pp" that have code in Puppet DSL - that has the include directive in it, we can use the class.</p>

<pre><code>include users
</code></pre>

<p>A manifest with just the single line above will apply the definition of class users to the system.</p>

<p>But when you say, <code>include users</code> how does Puppet know where to find the class defintion? We will answer that question in the next section.</p>

<h3>Modules</h3>

<p>A Puppet <strong><em>module</em></strong> is a collection of class definitions, file, template etc, organized around a particular purpose. In order to enable Puppet to find the class definitions, manifests that allow one to test the class defintions, files that may be required, etc that it may need to configure a machine for a particular purpose, we adhere to a consistent directory structure in which we place class definitions, any files that are needed etc.</p>

<p>All the modules are placed in a special directory specified by the <strong><em>modulepath</em></strong>.</p>

<p>The modulepath is setting that can be defined in Puppet configuration file. Puppet's configuration file exists in the directory <code>/etc/puppetlabs/puppet/puppet.conf</code> on the Learning VM.</p>

<p>You can also find the modulepath by means of the following command:</p>

<pre><code>puppet agent --configprint modulepath
</code></pre>

<p>Try running that command on the Learning Puppet VM now, and confirm that it returns the following value:</p>

<p><code>/etc/puppetlabs/puppet/modules:/opt/puppet/share/puppet/modules</code></p>

<p>What the above tells us is that Puppet will look in the directories <code>/etc/puppetlabs/puppet/modules</code> and then in <code>/opt/puppet/share/puppet/modules</code> to find the modules in use on the system.</p>

<h4>Module directory structure</h4>

<p>Modules are directories with a pre-defined structure, with class definitions, files etc in specific sub-directories. </p>

<p>Inside a module, manifests with class definitions are always placed in a directory called <strong><em>manifests</em></strong>. A class with the same name as the module is defined in a file called <strong><em>init.pp</em></strong>.</p>

<blockquote>
<p>Let's create our first module!</p>

<p>In the Learning VM, change to the <code>/etc/puppetlabs/puppet/modules/</code> directory, by running the following command:  </p>

<pre><code>   cd /etc/puppetlabs/puppet/modules/
</code></pre>

<p>Let's create our module directory structure by executing the following command:</p>

<pre><code>   mkdir -pv users/{manifests,tests}
</code></pre>

<p>This creates a directory called users, with two directories called manifests and tests within it.</p>

<p>Now let's create the definition of class users:</p>

<p>Using a text editor (nano, vim, or emacs - depending on your preference), create a file called <code>init.pp</code> in the manifests directory:</p>

<pre><code>   vim manifests/init.pp
</code></pre>

<p>For the content of the file, type in the definition of class users described earlier, also provided below:</p>

<pre><code>   class users {

      user { 'elmo':
        ensure =&gt; present,
        gid    =&gt; 'staff',
        home   =&gt; '/mnt/home/elmo',   
     }

      user { 'gonzo':
        ensure =&gt; present,
        gid    =&gt; 'staff',
        home   =&gt; '/mnt/home/elmo',   
     }

      group { 'staff':
        ensure =&gt; present,
        gid    =&gt; '1001',
      }

      file { '/mnt/home/':
        ensure =&gt; directory,
        mode   =&gt; '0755',
      }

   }  
</code></pre>

<p>Save the file after adding the above content.</p>

<p>Now let's create a test, to enable us to apply the class definition:</p>

<p>Using the text editor of your choice, create a file called <code>init.pp</code> in the tests directory now:</p>

<pre><code>   vim tests/init.pp
</code></pre>

<p>For the content of the file, use the following:</p>

<pre><code>   include users
</code></pre>
</blockquote>

<p>Great! Now we have a module called <code>users</code>!</p>

<p>Let's try and manage the resources defined in class users. It's as simple as using <code>puppet apply</code> to apply our test:</p>

<blockquote>
<p>Run the following command:</p>

<p>puppet apply tests/init.pp</p>

<p>You should see something similar to the following as the output:</p>

<pre><code>   Notice: /Stage[main]/Users/File[/mnt/home/]/ensure: created
   Notice: /Group[staff]/ensure: created
   Notice: /User[elmo]/ensure: created
   Notice: /User[gonzo]/ensure: created
   Notice: Finished catalog run in 0.40 seconds
</code></pre>
</blockquote>

<p>That's it, we just created our first Puppet module - a module that creates users to meet our requirements.</p>

<p>The two important things to note here are:</p>

<ol>
<li><p>Puppet's DSL, by virtue of its <strong>declarative</strong> nature, makes it possible for us to define the attributes of the resouces, without the need to concern ourselves with <em>how</em> the definition is enforced. Puppet uses the Resource Abstraction Layer to abstract away the complexity surrounding the specific commands to be executed, and the operating system-specific tools used to realize our definition! You did not need to know or specify the command to create a new unix user group to create the group <code>staff</code>, for example.</p></li>
<li><p>By creating a class called users, it is now possible for us to automate the process of creating the users we need on any system with Puppet installed on it, by simply including that class on that system. Class definitions are reusable!</p></li>
</ol>
<h1></h1>

<div class="page-break"></div>

<h2>The Puppet Forge</h2>

<p>The <a href="http://forge.puppetlabs.com">Puppet Forge</a> is a public repository of modules written by members of the puppet community for Puppet Open Source and Puppet Enterprise IT automation software. Modules available on the forge simplify the process of managing your systems. These modules will provide you with classes and new resource types to manage the various aspects of your infrastructure. So your task is reduced from that of describing the classes using Puppet's DSL to one of <em>using</em> an existing description with the right options.</p>

<h3>The puppet module tool</h3>

<p>Puppet also provide a module tool to help you download, install, list and manage modules from the forge.</p>

<p>For example:</p>

<blockquote>
<p>Run the command:
puppet module list</p>
</blockquote>

<p>This should list the modules currently installed on the system in the following format:</p>

<pre><code>/etc/puppetlabs/puppet/modules (no modules installed)
/opt/puppet/share/puppet/modules
├── cprice404-inifile (v0.10.3)
├── puppetlabs-apt (v1.1.0)
├── puppetlabs-auth_conf (v0.1.6)
├── puppetlabs-firewall (v0.3.0)
├── puppetlabs-java_ks (v1.1.0)
├── puppetlabs-pe_accounts (v2.0.1)
├── puppetlabs-pe_common (v0.1.0)
├── puppetlabs-pe_mcollective (v0.1.13)
├── puppetlabs-pe_postgresql (v0.0.4)
├── puppetlabs-pe_puppetdb (v0.0.9)
├── puppetlabs-postgresql (v2.3.0)
├── puppetlabs-puppet_enterprise (v3.0.1)
├── puppetlabs-puppetdb (v1.5.1)
├── puppetlabs-request_manager (v0.0.9)
├── puppetlabs-stdlib (v3.2.0)
└── ripienaar-concat (v0.2.0)
</code></pre>

<p>You can also search for, and install modules</p>

<p>With regards to things that we need to manage on our current VM, we can accelerate the process of defining the configuration for our machines using modules from the forge.</p>

<p>For example, to configure the test machine for our web-developers, we will need to install, configure, and manage the Apache2 webserver to serve web pages. So let us search for a module to manage the Apache2 webserver.</p>

<blockquote>
<p>Run the command:
puppet module search apache</p>
</blockquote>

<p>This should return something similar to the following:</p>

<pre><code>Notice: Searching https://forge.puppetlabs.com ...
NAME                   DESCRIPTION         AUTHOR          KEYWORDS 
5UbZ3r0-httpd          This module han...  @5UbZ3r0        apache   
7terminals-ant         The Apache Ant ...  @7terminals     apache   
7terminals-maven       Puppet module t...  @7terminals     apache  
puppetlabs-apache      Puppet module f...  @puppetlabs     apache
vStone-apache          Manage apache a...  @vStone         apache,  
zeleznypa-xhgui        The XHGui modul...  @zeleznypa      apache 
</code></pre>

<p>You can also search at the <a href="http://forge.puppetlabs.com">Forge website</a>. If you do so, you will a list on the results page:
<a href="https://forge.puppetlabs.com/modules?q=apache">Results for a search for the apache module.</a></p>

<p>Now, we can install the module we need. Let's install puppetlabs-apache.</p>

<blockquote>
<p>Run the command:
puppet module install puppetlabs-apache.</p>
</blockquote>

<p>This should return the following:</p>

<pre><code>Notice: Preparing to install into /etc/puppetlabs/puppet/modules ...
Notice: Downloading from https://forge.puppetlabs.com ...
Notice: Installing -- do not interrupt ...
/etc/puppetlabs/puppet/modules
└─┬ puppetlabs-apache (v0.9.0)
  └── puppetlabs-concat (v1.0.0)
</code></pre>

<h3>Using Modules from the Forge</h3>

<p>Now that the apache module is installed in our <code>modulepath</code>, let's look at how we might use it!</p>

<p>One way to get started using the module is to inspect the code written in Puppet DSL that is in the module's manifests directory at:
<code>/etc/puppetlabs/puppet/modules/apache/manifests</code></p>

<p>However, there is an easier way to do this for well-written modules that include documentation. Let's begin by visiting the <a href="https://forge.puppetlabs.com/puppetlabs/apache">page for the apache module on the puppet forge</a>.</p>

<p>The documentation on the page provides us insight into how to use the class definitions provided in the module to accomplish several tasks. For example, if we wanted to install apache with the default options, the module documentation suggests we can do it as follows:</p>

<pre><code>class { 'apache':  }
</code></pre>

<p>It's as simple as that! So if we wanted our machine to have apache installed on it, all we need to do is ensure that the above <em>class declaration</em> is in some manifest that applies to our node. We can also use the Puppet Enterprise Console to apply the class to our node.</p>

<p>What if we wanted to configure the default website served by Apache? The documentation tells us that we can use the following code to achieve that:</p>

<pre><code>apache::vhost { 'first.example.com':
      port    =&gt; '80',
      docroot =&gt; '/var/www/first',
}
</code></pre>

<p>This leverage a <em>Defined Resource Type</em> called <code>apache::vhost</code> that helps us create virtual hosts in Apache.</p>

<p>As you can see in the above, you can specify the port Apache listens on by changing the value for the parameter <code>port</code> in the above sample, to be the port you need Apache to listen on. </p>

<h2>Quest - Automated Test Machine Configuration</h2>

<p>The Quest in the motivating example requires us to configuring a machine foe web developers. Let's see what we need to do, with more details, this time.</p>

<h3>Problem Description</h3>

<p>Let's assume that you work as an engineer in a web development agency. You are tasked with configuring Virtual Machines for use by web developers to test their websites. You are given a detailed list of requirements.</p>

<blockquote>
<p>Requirements:</p>

<p>When configured, the system will provide web developers with a base system with the pre-requisite packages installed, with the user accounts and directories created.</p>

<p>The system needs to have:</p>

<ul>
<li>A user called <code>webtest</code> whose primary group (gid) is webdev</li>
<li>Another user called <code>apache</code> whose primary group (gid) is apache</li>
<li>A group called <code>webdev</code>
</li>
<li>The following directories:

<ul>
<li>/var/www - owned by user apache and group webdev</li>
<li>/var/www/html - owned by user apache and group webdev</li>
<li>/home/webtest - owned by user webtest</li>
</ul>
</li>
<li>The following packages should be installed:

<ul>
<li>httpd</li>
<li>mysql</li>
<li>php</li>
<li>php-cli</li>
<li>php-mysql</li>
</ul>
</li>
<li>MySQL server should be installed with root password 'foo'</li>
<li>The mysql and httpd services should be running</li>
<li>A mysql database called <code>webdb</code> should exist</li>
</ul>
</blockquote>

<p><strong><em>Note</em></strong>: You can see the number of tasks you have completed as you progress through the quest in the bottom left of the Learning Puppet VM terminals. The quest is complete when all the tasks for the quest are complete.</p>

<p>To check on which tasks are still incomplete, try the command:</p>

<pre><code>  progress
</code></pre>

<p>This will list the Incomplete tasks.    </p>

<h3>Define, Iterate!</h3>

<p>Since we want to automate the process of configuring a base system for the web developers, we will want to create a module, with a single class in it.  Let us call this module <code>testmachine</code>. This module will have a class called <code>testmachine</code> defined in it. We will also need a test manifest to enable us to test the class as we work on our definition of the class. Once we create the test file, we can use the <code>puppet apply</code> command to test our definition.</p>

<p>We want to develop the class definition through an iterative process. Starting with a simple definition that defines one, or a few resources, we want to test things as we go. So initially, you may choose to ensure that the  user and the group are created. Then you apply the test to make sure that your definition works as expected. Next, you may try to ensure that the required directories exist - so you add the resources to the class definition, and apply the test.</p>

<p>As you work through the quest, you can refer to puppet's documentation for the various types of resources using:  </p>

<pre><code>  puppet describe &lt;type&gt; 
</code></pre>

<p>and if you need help with the syntax, refer to previous code samples, or get help from the puppet resource command, for example:</p>

<pre><code>  puppet resource package 
</code></pre>

<h3>Steps towards success</h3>

<p>There will be an indicator to the lower right of the terminal window that shows your progress as you complete the tasks needed to configure the machine.</p>

<p>If you want to check on progress, with more details, run the command:</p>

<pre><code>progress
</code></pre>

<p>This will list the Incomplete tasks that you have yet to complete.</p>

<p>The steps involved in completing the quest are as follows:</p>

<ol>
<li>Create a module, called <code>testmachine</code>, in the correct directory, with the correct directory structure.

<ul>
<li>for this, remember what we learnt about the module directory structure</li>
<li>also remember that you will need a directory for your class definition, and another for your test manifest.</li>
</ul>
</li>
<li>Define the class called <code>testmachine</code>

<ul>
<li>remember that the class definition needs to be in a file called <code>init.pp</code> in the correct directory</li>
<li>also recall the syntax for class definitions - refer to the class definition in the previous section if needed</li>
<li>you may want to start with an empty class definition like the following:
&gt;        class testmachine {
&gt;
&gt;        }</li>
<li>and add resource declarations to the definition, one (or a few) at a time</li>
</ul>
</li>
<li>Create a test for the class testmachine

<ul>
<li>The test file should help you test the class definition as you work on it.</li>
</ul>
</li>
<li>Now, in an iterative manner, build the definition for the class testmachine, until you have completely described all the resources you need to manage on the machine.</li>
<li>When it's time to configure apache and mysql, install and use the modules provided by puppetlabs at the Forge

<ul>
<li>After the modules puppetlabs-apache and puppetlabs-mysql are installed, read the documentation for the modules and accomplish the following:

<ol>
<li>Make sure that the mysql server is installed, with the root user's password being set to 'foo'.</li>
<li>Ensure the httpd service is running, by installing the apache server using the puppetlabs-apache module. </li>
</ol>
</li>
<li>Remember to read the documentation for the module if something isn't clear!</li>
</ul>
</li>
</ol>
<p>The <code>puppet help</code>   command, and by the other puppet commands we have discussed before may help you as you proceed with the quest. Don't be afraid to experiment! </p>

<h1></h1>

<div class="page-break"></div>

<h2>The Road Ahead</h2>

<p>We hope that completing the quest was a lot of fun. Now that we have a class that can be used to configure a machine as a base system for web developers to test their work on, we can configure a new VM almost instantly, just by applying the class. Your work in defining the class once will pay off many times over in the time you save configuring the new VMs.</p>

<p>Although we learned only about using Puppet to configure a single VM - the one Puppet is installed on, it is possible to create a puppet master server that can be used to configure a lot of machines, each with the puppet agent daemon installed on them. This master-agent setup is the key to leveraging the ease with which you can manage entire networks of machines from a single, central server. The concepts are the same as we covered in this lesson - think of how, instead of just managing your Learning Puppet VM, you would be able to manage any machine with puppet installed on it, that can connect to your machine!</p>

<p>In subsequent lessons, we will learn more about how the Puppet Agent and the Puppet Master interact with each other, how you can dynamically generate content for files etc. For each lesson, we will have a Motivating Example, and a quest to complete!</p>
</div>    <div id="side_nav">
        <h2> Quests </h2>
        <ul>
<li><a href="intro.html">intro</a></li>
<li><a href="q1_getting_started.html">q1_getting_started</a></li>
<li><a href="q2_ease_of_puppet.html">q2_ease_of_puppet</a></li>
<li><a href="q2_wow_example.html">q2_wow_example</a></li>
<li><a href="q3_accessing_your_quests.html">q3_accessing_your_quests</a></li>
</ul>
</div>
</body>
</html>
